hello everyone my name is Darwin I work for gitlab I want 
to talk to you a-little bit about the architectural 
trade-offs for gitlab Runner workload-authentication and 
authorization into Cloud environments so we get 
the-question you know how can we set this up so that a 
gitlab runner can access one-of our 10 or 100 or thousand 
accounts in a given cloud provider and this is a-growing 
consideration for large organizations or or any 
organizations-that are using Cloud accounts as a 
fundamental security boundary for-development teams so 
let's Dive Right In Here first I'm going to reflect 
the-three ways that we do this the first way we have is 
cloud keys and masked-variables in gitlab this is a pretty 
common first level permissioning that-you see in most 
products this is not the most secure way to manage 
Cloud-authentication both in terms of where you're storing 
this information as well-as the fact that you're handing 
out keys that you may or may not be actively-rotating uh 
there are benefits and challenges so as we go through all 
three-of these you'll see that there are architectural 
benefits even for-something as straightforward as keys and 
then the IM roles assigned to compute-when we assign IM IM 
roles to compute and then we put that Runner compute-inside 
of the cloud account that we want to access we get this 
nice capability-that anything sent to the runner has 
whatever permissions you assign to it-this is a little bit 
better than keys since there are there is no-authentication 
involved but the other challenge that you have is that 
that-authentication is one for all for every job that runs 
on that Runner then-finally we have open ID Federation 
which is your oidc JWT token capability that-allows you to 
get very granular about your mapping between gitlab and a 
given-role in a cloud account when you use this you can get 
as granular as a given-Branch inside of a given project is 
mapped to a certain role you can also-use wild cards when 
you set this up so that potentially just a given 
group-hierarchy is all mapped to One account so you have a 
lot of flexibility here so-it's the most sophisticated it's 
also uh does not have the problem of sharing-Secrets 
because you have actual Federation between the systems 
does-require that you Federate each Amazon account into 
your gitlab instance so-that this can all work I want to 
show you now a tra of-visualization that allows us to look 
at this information in a slightly different-why this is a 
spectrum here and when we go through this this information 
is-purposely reflected as analog not quantitative we are 
really kind of-giving a a rough measure of where this might 
be you might even evaluate this-and say Hey you know you're 
not putting these in the the right analog spot at-our 
company we'd put them over here and that would be perfectly 
fine I think-this is actually a powerful way to do it 
because a lot of these decisions can't-be boiled down to 
quantitative uh concerns and even if we do if we 
start-giving things a rating of a one or a two or a three 
really we're doing pseudo-quantification so we start 
creating numbers that roughly represent something-that's 
rough in this methodology we just leave it rough so I'm 
going to put Keys-here at this point on this spectrum of 
Runner management effort how much work-does it take to 
manage the actual Runner instances themselves put a signed 
to-compute over here to to requiring more Runner manager 
effort and then oidc and-JWT over on the minimum side what 
this basically means is the more that we are-to the right 
the more likely we can use a highly shared runner for 
example an-autoscaling cluster of Runners to access a lot 
of different Amazon accounts now-these considerations of 
this green box is backed by a variety of sub criteria-so to 
speak or sub tradeoffs and so one of those is pipeline 
mapping flexibility-for permissions so with oidc you have 
the maximum and then when you go over to-assigning to 
compute you have the least flexibility in terms of mapping 
various-projects branches and git refs in gitlab into a 
specific permission-set also the location of the runner if 
you're assigning it to Cloud compute to-give it Cloud 
permissions then it has to be in the cloud where on the 
other side-we don't really care where the runner is because 
it's not using its uh you know-its location so to speak as 
a way of establishing-permissions and then finally Runner 
spra all so when you assign to compute you-are then causing 
compute to be a fragmentation boundary for 
security-concerns and other words if I need 20 security 
contexts then I'm going to need-20 Runners pursuing that 
approach causes U more-fragmentation uh next is recurrent 
daily human processed complexity what does-that mean that's 
the stuff we can't automate and sometimes when we 
automate-we actually go backwards on this because our team 
gets more automated but another-team in the organization 
actually has more recurrent daily human process-complexity 
or we basically didn't really automate something if we end 
up-balancing these two things uh to zero if we end up 
causing more human toil we've-actually unautomated in a way 
because the whole idea of automation is to swap-machine 
toil for human toil so with keys I'm going to put it here 
assigned to-compute over on minimum and maximum for oidc 
JWT this is because the-administration complexity increases 
so administering this day-to-day setting up-roles for new 
accounts all of those things has to happen by humans at 
some-point then developer user complexity so how 
complicated is it for your developer-users oidc JWT tends 
to be more complex here's a key to reading this 
diagram-notice in the bottom right that the flag pole with 
a broad bottom indicates that-you have a range of outcomes 
along this spectrum based on how you implement so-in the 
case of oidc J WT if you decide that you're going to be 
very granular in-what roles you assign to what contexts on 
the gitlab side you can make this-even more complicated so 
the more specific you get about how you design it-the more 
complicated it becomes and you can also back that off and 
say hey we-want one role for this entire group hierarchy 
and make it less complicated-so that's what that means that 
you have your choices within how you design this-could uh 
drive that harder uh then architecture and engineering 
complexity-so when you first set this up thinking through 
exactly these trade-off matrixes-we're talking about and 
putting together uh something that works for your 
company-that has a reasonable admin overhead well so keys 
are over here it's pretty-straightforward compute somewhere 
in the middle and oidc JWT moves to the left so-you're 
going to have to spend more time figuring out how to make 
this work and-then we have another second set here if you 
if you are focused on doing-self-service so developers have 
to figure out themselves how to map oidc-and JWT uh into 
the target environments if they're responsible for finding 
that-information somewhere in your organization and coding 
up their own-oidc mapping then of course you're increasing 
uh their design complexity-they hopefully only have to do 
that once at the beginning but it can be more-challenging 
then we have security best practice so lower on the left 
higher on-the right uh we have keys over here assigned to 
compute sort of in the-middle and oidc JWT on the right one 
of the aspects of this is credential-exposure risk so you 
have more with keys very little with assigned to compute 
and-because oidc is using temporary tokens you have no risk 
there and then-automatic credential rotation uh this is in 
in a way it's na on-oidc and um there's more effort to make 
that happen with keys and then are-permissions 
automatically granted to CI code on Keys yes and then an 
oidc you-have to opt into oidc to turn it on for a job so 
there's a little bit of control-about whether every job 
ends up inheriting those permissions or not we-have the key 
again one thing I want to mention is you want to be careful 
of two-things that are what I call ideological architecture 
one is that you only need-to pick one of these models by 
only picking one that's sort of the-architect's best world 
is to have one model to suit all but frequently this 
is-pursued to a bad end run so you might have a situation 
in your or organization-where 80% could use a sign to 
compute just fine and the others should use oidc-or 
something similar to that but if you force it to be the 
most sophisticated-approach for everything you can end up 
violating paro's law and you end up uh-spending a lot of 
time on creating say oidc settings for repositories 
that-aren't benefiting from it an example this would be um 
sometimes deployment-compute is better assigned to compute 
because you can shut down that Runner-when you're not using 
it give it only deployment permissions um and have it 
in-the Target environments and so don't be afraid to pick 
more than one model-making sure that you take a look at 
what are our use cases and so if we have use-cases it can 
be forced into two models at a great savings instead of 
picking-one model and having you know a very high cost then 
that might be a good idea-to think about that so don't 
pursue one size uh fits all uh type architecture-the other 
challenge we run into is oh if I pick the most 
sophisticated I'll be-safe it'll never be I'll never run 
into any limitations and so that's a way of-deferring a 
decision that's also a decent um architectural disposition 
in-general however I'm trying to show with these diagrams 
that picking the most-sophisticated also introduces 
complexity and some of that complexity is human-complexity 
that you can't automate this is the basic lay of the land 
in terms of-the tradeoffs uh for architecture there's one 
other thing I want to-highlight we're going to go in the 
next slide into controls you have in gitlab-for code merges 
because no matter what you do here now that you set Runners 
up-to be able to have permissions in environments now 
within gitlab you have-to be careful to make sure that you 
understand that if someone can merge-code into a repo Bound 
for one of these runners or using some of these 
Runner-permissions they now essentially can obtain those 
permissions even though-they personally have not been 
granted them so it can be an attack Vector-there's a lot of 
controls in gitlab that you can then take control of how 
merges-happen who can merge who can deploy and there's all 
kinds of controls and next-we're just going to take a quick 
look at an overall slide that allows that shows-you the the 
full raft of controls there's another video that actually 
goes-through each of these controls uh that I'll forward 
reference for-you here is the overall picture of the 
controls that you have in gitlab to-start controlling what 
kind of jobs can run on Runners every job in a pipeline-can 
run on a different Runner and those Runners might have 
different permissions-according to what we just looked at 
previously these purple boxes are the-ways in which you can 
control what code merges to what branches and 
therefore-uses what Runners there is a full video that 
explains each box uh with a certain-amount of detail and 
that link is right there on the screen but I wanted to 
let-you know that you have these two layers so once you 
establish kind of Runner-permissions on the compute level 
then you can also start working with some of-these controls 
to make sure that the right folks can do the right things 
with-the right Runner permissions into your 
Cloud-environments so this has been architectural 
trade-offs for gitlab-Runner workload authentication and 
authorization into Cloud environments-I'd love to hear from 
you if this has been helpful for you and I'd like to-hear 
feedback too on the visualization format if that's 
something that works-for you for architectural trade-offs 
thanks so much
