it's difficult to become a good software designer usually 
we just-wait around and practice and hope that we become 
better over time-there's an old saying if wishes were 
horses beggars would ride-and as a software developer who's 
trying to grow-it can be very frustrating to hear from 
other people-that we should just make our designs simple 
because if i knew how to do that-i would already be a good 
software designer-right so what i'm going to talk about 
here-today is that by using contracts it's not a full 
answer for how to be a-good software developer be a good 
designer but it is-putting us on the right path and it 
makes certain things that-are only really visible to 
experts once they become good software-developers it makes 
those kinds of things more visible to-everyone and allows 
you to get better faster in particular we're going to 
see-how contracts reveal the messiness in your-design if 
it's there how they can help the separation of-concerns and 
help how they can help communicate the design-from out of 
your head into your colleagues heads and vice versa-so 
let's take an example to start with and i'm going to say 
right off the bat-that i've made this example as crazy as 
possible and you wouldn't do this-literally but let's 
imagine that a customer calls up and reports a bug-and 
their invoice was calculated wrong it's-off by five dollars 
and here's where the crazy part starts-let's imagine your 
co-worker suggests let's go change the ad routine okay 
so-nobody would really change the ad routine it would ever 
suggest that-but the point is there's a lot of times when 
there is a-wrong place to add some bit of logic and this is 
one that we can all agree on-is probably not the right 
place for us to fix-but your co-worker says look for this 
exact invoice there's an addition-happening of 10 and 15 
and it really needs to return five-dollars less so we can 
just put the if statement in there-now what i want you to 
imagine is putting being in the situation where-you're 
arguing against this person there's no question that this 
patch to-the code is going to work right now it might 
at-some point cause a different problem right because-now 
the addition code is more complicated and it's got 
this-funny little special case in it that's going to give 
weird answers-and so probably you're expecting a bug to pop 
up somewhere else but at this-moment your colleague has a 
proposed patch it's-probably like a one-line fix and you 
need to argue against it okay-and this is the situation i 
want you to consider yourself in-so here's what would 
happen if we had contracts right if we were thinking-about 
this starting with contracts so here's a plausible contract 
for the-ad routine it returns x plus y within some 
degree-of precision okay and if we took your 
colleague-suggestion you might have something like 
this-when x plus y is you're adding 10 and 15 it returned 
20 which clearly is a crazy-thing to do but it's in the 
contract now otherwise it-returns x plus y now the thing 
about this is as soon as-we write that contract down your 
design sent starts tingling just-like it did previously 
when you just had a subjective feel for it-but what you can 
do is you can point to that contract right and you say-that 
contract looks wrong to me and you and your co-worker 
can-have a discussion about it and so you can say there's 
no question that-contract is now more complicated than it 
was before-right and you can even argue about whether that 
contract is surprising-whether it's going to cause bugs and 
so forth okay-so again i would like you to take this 
example not exactly about editing-ad routines but instead 
of generalizing and imagine-there's some code somewhere 
someone's suggesting sticking an if statement in-it and 
you're trying to say look but it's-going to complicate the 
contract and cause trouble-so way the way i think about 
this is that contracts are like an invisible-hand that is 
guiding your design and they-don't tell you what to do i 
mean clearly the contracts are just a statement of-what 
your design is but by writing down the contracts and-making 
them visible they can open your eyes and make 
visible-something that you did that like might be a small 
amount of code but-it's actually conceptually a very big 
deal a conceptually a big-problem so what the contracts do 
is they draw-your attention and allow you to seek the 
simplicity-yourself okay so in that previous example-we 
were not seeking simplicity we actually created 
complexity-and here's the thing in the end you are the 
force of simplicity even though i-phrase it as contracts or 
the invisible hand that-guides design what they're really 
doing is they're allowing-your natural desires for 
simplicity and for elegance-and for good design to come out 
and it gives them-gives that something that you can 
tangibly look at-in terms of like well if i'm overall in 
the system making my contract simpler-i'm probably on the 
right path for making a good design-so i've thought about 
this and i think there's several different ways that 
the-contracts influence us and cause us to want to change 
our designs-so for example uh we hate typing long contracts 
and we-seek short ones right we don't want our-contracts to 
feel like a convoluted legal uh document that we-all hate 
instead we want them short and sweet-okay so just the act 
of trying to find that short sweet contract-is going to 
cause us to do a couple things first-that we would operate 
uniformly because every time we have to add an if-statement 
we're going to see that in the contract-and then second 
we're going to minimize the number of edge cases we have 
so-if we can find a way to say for any kinds of values you 
pass in-we consistently do the same thing it's a whole lot 
easier than saying-well unless there's zero or unless 
there's 10 or unless in this case there-was 10 and 15. so 
another way-is that that contracts influence us to towards 
good designs is that they-encourage us to decompose one 
complicated method into two simpler-ones okay and also if 
you think about this from-the testing angle it's the same 
kind of force-it can be much easier to say what this one 
simple thing does for example add-than it is to jam 
together add plus the bug fix-okay so you end up uh 
separating out a few things-and having greater confidence 
that the small things work in isolation-uh very simply 
another way that contracts influence-us is that they 
encourage us to operate on an entire domain-now you may if 
you've been studying functional programming know that 
what-i'm hinting at here is a total function okay so for 
example um imagine you had a-method like uh is pretty and 
it was operating on a-string which was uh representing a 
color so you-can say is pretty red and you'd say well but 
for some strings-that's not well defined so if i said is 
pretty-hovercraft man well i don't know what i don't know 
how to answer that question-because it's not a color so 
instead if we had an enumeration of-colors for example red 
green and blue i could operate on all of those-consistently 
and be be confident that uh you know for anything you pass 
in in-that enumeration i i know how to act on it uh one 
more way-that contracts influence this is they encourage us 
to minimize side effects-again going back to uh some of the 
ideas from functional programming-this is talking about 
pure functions it's easier to reason about things 
that-don't have side effects okay if they only depend on 
the inputs-and the only result that you see is coming from 
the outputs-and then finally related to the hating long 
contracts-if we find the same sort of thing being stated 
over and over again-for example in the post condition and 
my linked list does not have a loop at the-end i can factor 
that out and to say really-that's just me factoring out a 
common statement no matter what happens my-linked list will 
never have a loop-so the result of all this all these like 
the golden uh-the invisible hand that's that's nudging us 
in the right direction-is that you're going to have 
complications in your program-but it tries to guide those 
it has the effect of guiding those-into more appropriate 
phrases places so going back to that customer 
invoice-example the customer invoice was wrong look 
you-have to fix it but there are better or worse places 
that you can tuck away-uh that logic or that uh the code to 
fix it-so when we're programming with contracts and we're 
trying to keep our contract-simple it we love this idea 
that we compose-simpler parts into more complicated ones so 
we're going to have to find somewhere-to fix that customer 
invoice but it probably is not going to be the-ad routine 
because it had this terrible effect on the contract i've 
got-so what i've noticed is when you start thinking in 
contracts-you start trying to find ways i can say well this 
is a big problem to solve-but this smaller part of this big 
problem i can like write a simple-contract and solve that 
completely and then i can chip away-until eventually you've 
got a lot of things which are so simple and 
really-obviously work that you can compose them in-and 
solve the bigger problem and finally even if you can't find 
a really good-place to put the complication that you're 
dealing with-even when it goes into the wrong place the 
contract is at least telling you-and warning other people 
about what's going on here and i want to contrast-that with 
you've got a module out there it's got-some if statements 
in there you didn't ever-you haven't read about and those 
things are just going to cause you a surprise-at some point 
at least by putting in the-contract you know you're 
highlighting the fact that there's something-surprising 
that's going to go on here so what happens to teams when 
they use-contracts the first thing i've noticed is they 
end-up using logic as a tool for simplifying their thinking 
not just procedural-thinking they use procedural reasoning 
and-procedural thinking of course but what they use that 
for is reasoning-to make sure that the contract is being 
satisfied so they'll read through the-steps of an 
implementation and go yep i think i'm pretty sure that 
what-the contract that we're talking about this code will 
actually-uh satisfy that and then finally two particular 
kinds of things are top-of mind for these teams the first 
is predicates and the second-is in variance okay that uh 
when a team is using contracts-they talk in terms of what 
must always be true or what must-never be true in certain 
modules or certain methods and-they start building up a 
vocabulary of predicates-so for example is a premium 
customer right and they build those up and they-talk about 
them a lot because that's the language that they're using 
the language-of logic that they see in the contracts-so i'm 
just going to give an example now this is a pretty standard 
design-for the way that you can build a server and you can 
build it with-three modules the first one is dealing with 
the http handling or whatever-protocol you're using for 
talking to the outside world the second module-is the 
business logic and that is the logic of what you do so for 
example-maybe you're calculating invoices like we talked 
about the early example-and then the third module is 
persistence which is uh-okay i've got this invoice i need 
to put it down on disk for permanent storage-or i know i 
have a customer who's just coming here i need to pull their 
invoice-off the disk okay so pretty standard design to 
have-those three different modules but what i want you to 
think about is-the the contracts uh the precondition are 
the uh-predicates and the invariants that we would have 
here-so if i had one module that was only doing the packing 
and-unpacking from say http and json and moving that into 
the-business logic of dealing with invoices that module 
would be allowed to depend-upon the interchange libraries 
let's say a json library-it would be allowed to depend on 
the http libraries for parsing the http-message that comes 
in and it would depend upon our logic for-the business 
logic or our module for the-business logic but what it 
would not depend upon-is the persistence or the libraries 
for the database-okay that's categorically off the table so 
there's an invariant there-similarly with the business 
logic it would not depend on http or json or-exchange data 
types it would also not depend on the database-or remote 
procedure calls or any of that kind of stuff-it would be 
allowed to depend upon our persistence module so in 
this-business logic it has like everything about invoices 
it knows how to deal with-invoices but what you've done is 
you've factored-out and made the problem simpler by 
removing-all those uh those other problems and then finally 
in the persistence-module again it would have no dependency 
on the http-json the the data types that are there or the 
business logic-but it would know about the database or 
maybe rpcs that you use-remove procedure calls for for for 
chatting with other stuff-and of course it would depend on 
the data types as they exist on disk-so again the point of 
all this is that uh-using contracts or thinking in 
contracts and thinking about-predicates and invariants has 
this invisible force on your design-and what you'll see is 
when teams are thinking about contracts top of mind-that 
they start having designs that look like this so instead of 
like-one big server right module that does all of these 
things it's been factored-out into three things okay three 
different modules-each of which has clearer contracts that 
are easier to test-and easier to understand so here's a 
concrete suggestion-when you're writing your code and let's 
say you're using a version control-repository like github 
or something go ahead and drop a-readme.md or design.md or 
architecture.md file-right next to your code and write out 
the the-the rules of the road here this is a description of 
your design-and it is great at communicating the the design 
that you've got with the rest of-the co-workers so in 
summary it's difficult to become a-good software designer i 
if i could wave a magic wand and say-you know being here 
let me help you get there-immediately i would do that what 
i'm talking about here with-contracts i'm saying because i 
believe it will-help accelerate you towards becoming a 
better software designer i believe-that thinking about 
contracts is a mindset that helps us make our-design simple 
the contracts reveal the messy parts-they help us separate 
out two different concerns to the extent that we can-and 
they help a team talk about the design and communicate it 
so everyone-understands how the design is supposed to work 
now-the contracts aren't foolproof but they can help you 
guide you can-guide you towards simpler designs and help 
your desire to make things-simple uh they they let you 
operate on that and-achieve that better
