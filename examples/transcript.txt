hi there everybody ah about 50 years ago Edsger Dijkstra in 
his Turing Award-lecture told us that we should be paying 
attention to intellectual control-because it's really hard 
to understand what your program is gonna do when you-run it 
you'd like to be able to look at it and have some 
confidence that it's-gonna do what you expect now I don't 
have any code from 50 years ago that I-can easily show you 
and if I did it probably would be on punch cards but-what I 
can do is talk to you about 25 years ago when I started 
programming-surprisingly it was pretty similar to what 
you're doing today I happen to be-working in small talk you 
may not remember this but small talk has lambdas-in it and 
it has data flow operators so while Java just got the 
ability to do-map and reduce and filtering on collections a 
couple years ago this has-been in lots of programming 
languages for a long time if you were to look at-me at my 
desk I'd be sitting there in front of a Solaris workstation 
with-Windows and the only thing that would look different 
is that the title bars-are a little old-fashioned but 
otherwise completely familiar to you we also 
did-object-oriented alysus design and programming which is 
what a lot of you-are also doing today maybe less analysis 
and design but certainly the programming-and something that 
we're a bit ahead of the curve on is we were doing 
delivery-every two weeks okay pretty good we were getting 
code in production no big-disasters the thing that's a bit 
interesting is that 25 years ago very-few people were doing 
testing ubiquitously if I had to have you guys-raise your 
hands I think that almost everybody would say we all 
have-regression test Suites today and that's why we feel 
safe to push our code in a-production because the tests all 
went green so this should be surprising to us-like how is 
it possible this team was able to regularly get code 
into-production and not pull their hair out and worry about 
it all the time what was-going on is we were following some 
of the advice of Edsger Dijkstra and not-just us but 
everybody else we structured our code in such a way-that it 
was more amenable to thinking through it and having 
confidence in what-it was doing now we definitely would run 
the program and we would click on the UI-and make sure it's 
doing what it's supposed to do but that kind of 
testing-that manual testing was a double check to make sure 
that our reasoning was-right rather than the primary kind 
of confidence that we got if I think about-what I do today 
I have a big wide snuggly blanket of tests covering my-code 
and I get an enormous amount of confidence from the fact 
that those-things are there and they make sure that the 
code that was working yesterday also-works tomorrow as I 
add new code it hasn't broken anything okay now the idea-of 
still doing reasoning along with that testing is a hundred 
percent compatible-but I find that not as many people do it 
especially teams that are that we're not-exposed to these 
ideas 25 years ago say and there's something that's a 
bit-worrying to me and I've done this and I've seen other 
people do it I call it-whack-a-mole development maybe 
you've done it too it goes something like this-you write 
some code but you don't really fully understand everything 
but you're-trying to get everything done so you write this 
code and a test breaks you're-like oh okay well let me go 
over to fix that and understand a little bit more-you fix 
that test well something else broke okay another test broke 
it fixed-that great everything's looking pretty good oh the 
end-to-end tests are broken-okay you go fix that and you're 
off to the races at that point the tests are-green but I 
feel worried that actually everything is okay because by 
definition-we can't test everything the tests are a 
representative sample of the things that-are going on right 
so when I engage in that kind of whack-a-mole behavior 
where-I realize I don't have full understanding and what's 
going on-maybe I'm leaning on the wrong thing and I was 
really neat on tests when I should-have been leading 
leaning on reasoning so I need to introduce that 
vocabulary-of intellectual control here the idea with 
intellectual control as Dykstra was-talking about it is 
before you run the code do you have-good confidence is 
gonna do what you expect now Dykstra with the mat was 
a-mathematician by training and so he held the standard to 
say we should be proving-our code to be correct very few of 
us do that today although if you are in your-IDE and it 
says this variable might be null and it looks like 
your-dereferencing it believe it or not that's actually the 
same proof-infrastructure that's demonstrating that that's 
going on but he introduced this-idea of structured 
programming probably most famous for the fact that you 
no-longer have go-to statements in your code but the idea 
was far bigger than-this it was that we can structure our 
code in such a way that makes it easy or-harder to reason 
through it and have confidence in what it does so 
really-beyond the proofs there's all kinds of things that 
we do today or don't do-today that can give us more or less 
confidence I would include things like-having a really 
strong type system instead of being string Li typed 
if-you're familiar with that structuring your code so it 
has consistency using-abstract data types designed by 
contract and so forth so let-me contrast intellectual 
control with statistical control now with 
statistical-control you run the code once or many times and 
because you've run it in-representative cases you give 
yourself confidence yeah I ran it it does what I-expect it 
to do okay so with these two things I think you can see 
these are two-different ways of getting to the same answer 
which is you know I'm building-code that does what I expect 
and because you guys have been kind enough to all-come here 
I feel like I should say something a bit radical and a bit 
edgy-that disturbs you so so here it is I worry that our 
reliance on testing has-numbed us to the fact that we're 
doing less reasoning than we used to and that-there's some 
danger in this I'm gonna spend the rest of the talk 
building up-to this so that you don't think it's quite as 
radical and crazy as you as it-might first seem projects 
don't start out out of control they start out in-control we 
have intellectual control and-statistical control in these 
slides I'm using IC and SC-because it otherwise is big and 
noisy so what I'm showing here with one box let's-say that 
that's one chunk of code one module and that's at the 
beginning of-the project and I've got both intellectual and 
statistical control now-things never start are things never 
stays so simple so here's an example-where we've got two 
modules okay and the first module is working with the 
second-module again everything is small I've got it all 
under control and notice that-there's a containing box and 
what I mean by that is that's the system as as a-whole okay 
and with that system again I have both-intellectual and 
statistical control again nothing stays so simple so on 
this-slide I'm gonna show four modules but it could be 40 
or 400 or 4,000 okay the-point is you have a bunch of code 
and things are interacting with each other-what I'm showing 
here is the first thing that you usually lose 
intellectual-control of is the big assembly just because 
the state space is so large it's-hard to have confidence 
that everything's working okay so while-things were small 
you could think through it as things get really big you-end 
up leaning on your end-to-end test to make sure that things 
are really-working but it gets worse invariably schedule 
pressure or some Engineer that-didn't quite understand 
what's going on gets in there and starts hacking 
some-module and you sort of lose your clear understanding 
of what's going on inside-there and so it reverts so it's 
only got statistical control the tests make sure-it 
continues to work but if you had to describe it you'd have 
a really hard-time the problem I've noticed is that it's 
kind of infectious and once one-module you can't have a 
clear description of what's going on the-modules around it 
tend to lose their clear descriptions right it's it's 
just-doing it because it's supposed to do it that way and 
it did it that way-yesterday we can make sure it does it 
tomorrow so in this way you can see that-we on our projects 
we drift towards using statistical control more than we-use 
the intellectual control I would imagine many of you 
are-wondering at this point gee George what about 
refactoring-refactoring solve all known problems the answer 
is I love refactoring I do-refactoring all the time okay 
but we must remember what the definition of-refactoring is 
the definition of refactoring is that it's a 
behavior-preserving transformation of the code right okay 
so if something if somebody's-come into some module that 
was coherent and made sense and adds a bunch of 
if-statements that no longer make sense refactoring can't 
change those-requirements right refactoring can just 
restructure the-code so that it is clearer to understand if 
we need to go in and say simplify the-requirements or 
renegotiate interfaces between modules-that's not 
refactoring that's redesign and the problem with redesign 
if you've-ever gone into existing code you can understand 
all the code but you may not-understand why it does it so 
you're forced into this problem of having to-rediscover the 
program requirements which have become murky and lost 
over-time before you can redesign it but I think the most 
compelling argument here-is for about 20 years there's been 
a rallying cry that says go forth don't-really work no one 
says don't worry about intellectual control but in 
many-ways projects have gone forth without leaning on 
intellectual control and they-were hoping that refactoring 
would save them I would say we would see lots of-success 
stories if that were true but I think we instead see lots 
of teams-grappling with technical debt so the problem with 
this shift towards-statistical control which usually 
happens without anybody saying I think-that's a good idea 
it just sort of happens on projects is that once you 
go-down that path it's very difficult to reverse course and 
come back if you ask-any gardener how much weeding you 
should do and when you should do it their-answer is always 
the same it's like stay on top of the weeding because once 
the-weeds take over it's really tough okay but remember if 
you've got two weeds or-one weed it's only twice as hard to 
do two weeds as one weed okay it's linear-when complexity 
takes over your project it's a super linear problem right 
you-know two modules of complexity is way worse 10 mod-way 
more than 10 times as hard okay because everything is a big 
nest of-trouble so what I've noticed is once a project 
loses its intellectual control-very few teams have either 
the money or the time or the you know opportunity in-the 
market to come back and recover the control over the 
software they have to-just keep it running and they 
continue to use the testing so what was it that-we were 
able to do 25 years ago I mean what was magic about 
keeping-intellectual control then what I found is that 
simply wrestling with the-program and trying to keep 
intellectual control has the effect of pushing down-on 
complexity I don't have time to like do a rigorous 
demonstration to you guys-this is true and I'm not sure I 
could do one but but here's sort of my intuition-that leads 
me to this conclusion the first thing is that complexity 
builds up-over time on projects we get new requirements in 
the bureaucracy you know-regulations and so forth nothing 
really makes any sense we just have to-accommodate it the 
second thing is our minds are limited like we're 
pretty-smart like our profession attracts people that are 
pretty good its-problem-solving but we all recognize we 
have limits there's only so much we can-keep in there the 
third thing is that for any given problem you've got a 
bunch-of different ways you could solve it okay and some of 
those things are more-complicated than others it may take 
you longer to find the simpler ones or to-cast your problem 
in terms of the simpler solutions but they're out there-a 
lot of times so what I find is that doing this daily search 
for simpler-solutions because you're trying to keep the 
code inside of your head overall has-the effect of keeping 
complexity down so let's go back to that big 
seemingly-contentious statement before which is that our 
reliance are leaning heavily on-testing in the last 25 
years which has been undeniably a good thing again 
is-perhaps blinding us or numbing us to the alarm bells 
that would otherwise be-ringing that say that we're not 
keeping the cuff of software under as much-intellectual 
control as we did said another way-statistical control that 
we've been using is numbing as to our loss of-intellectual 
control here's a notional diagram of what I see happening 
in-projects so a friend of mine recently he's in a startup 
and he tells me about-how this thing is going on for 
several years and then like all of a sudden the-software 
team is making no progress and when he goes in there and 
starts-chatting with the folks he finds out the complexity 
is built up to the point-where these guys are not making 
any forward progress right that's that's-been the problem 
and so if you were to graph the amount of control this 
team-had over time I think it might look something like 
this early on everything-fit in their heads they were 
following practices that were not necessarily what-you 
would consider best practice but they were good enough and 
they were-making progress and they're out there making 
money at some point they shifted-and they shifted into the 
point where they really lost intellectual control-and 
that's why I call this zombies in the sense that their 
control only seemed-to go down a little bit but 
realistically they were now in a dead-end of a project that 
they couldn't easily back out of okay and so in some-ways 
you might believe there's going to be that collapse of 
productivity once-once people get to the their brains get 
full it just hasn't happened yet so-we're here at a 
software architecture conference so let's chat about 
how-specifically this type this works with software 
architecture to start with-let's consider just a single 
module like a class file or another kind of unit of-code I 
think that both statistical control and intellectual 
control work-great in this particular case you can blanket 
it with tests and you know it's-small enough that that 
works pretty well I could read the test or maybe I can-even 
write the test in such a way that I understand the code 
pretty well but I-can also use intellectual control there's 
a great bag of software-engineering techniques that include 
abstract data types information hiding-structuring things 
as state machines that help me in my ability to 
reason-through that code so I think all of those work 
really well for a single-module how about for your entire 
system it's different for the entire system-here's the 
argument I'm going to make I think all of you guys would 
agree if you-look at your current project and you count the 
number of unit tests versus-the number of end-to-end tests 
there's something like a hundred to one maybe a-thousand to 
one maybe even more of a ratio the number of end-to-end 
tests you-have versus unit tests is that because the state 
space of your individual-modules is so much larger than the 
state space of the entire program well of-course not that 
doesn't make any sense you know by definition the state 
space-of the whole program is is big so then why aren't we 
dumping tests on it-because it's hard you know like these 
things take a long time to run they take-a long time to 
write they're finicky they're often flaky so I think 
what-really is going on with software architecture and the 
reason you guys are-here today is that we have 
traditionally in our field of software architecture-used 
intellectual control to keep things on track we're here in 
Manhattan which-has a grid plan right grid plan was an 
architectural decision made early on-that is reaping pros 
and cons as we as we're here today so when you set up 
an-architecture you might say I have these views of the 
problem I'm gonna apply-certain standard styles to it I 
understand that I'm gonna promote-latency and I'm gonna you 
know get hurt in some other way and I might do some-choice 
ting to enforce some of these constraints so what can we 
do-I'm obviously what I suggest is you should delete all 
your tests just delete-them all right now and go no before 
Twitter lights up what I'd suggest is-what we really want 
is both okay but the real question here is how can we 
keep-that intellectual control that we start with how can 
we keep it going the first-thing to do is culture right if 
we start having this conversation if you use 
this-vocabulary of intellectual control and talking about 
what structured-programming was really all about you can 
perhaps get everybody on board and try-to keep this going 
failing that the answer is more testing-but of a different 
type property based testing and model-based testing let 
you-state what your abstractions are in your tests and make 
sure that they stay there-the reason that's interesting is 
that there's a strong cultural bias against-deleting 
somebody else's tests right so if you go into a module that 
has-property based testing or model-based testing and you 
need to extend it you're-kind of on the hook to extend that 
that those tests to work in that same way if-you look at 
your project and you suspect that you actually have low 
amounts of-intellectual control I suggest asking the two 
questions first-what about your process is driving you 
towards intellectual control if the-answer is well we're 
being driven to make sure it passes the style guide 
and-make sure it has good test coverage and that we deliver 
on time but there's no-nothing about the process that 
encourages intellectual control that's-the first place to 
look the second thing is companies can accidentally 
reward-people that create complexity and make it hard to 
reason and and unfortunately-discourage people who collapse 
that back down like we all want to make it nice-and simple 
but sometimes the incentives in the company don't work that 
way so-overall thank you guys very much for listening to 
this talk this is kind of a-an abstract topic to be talking 
about early in the morning what we've been-chatting about 
here is the way that we keep control over large amounts 
of-software which is an inherent problem with software 
architecture in the old-days before we all decided that 
testing was cool we had to structure the code in-such a way 
that it was easy to think through okay today we have 
that-opportunity along with our tests and what we're really 
shooting for is-something like a nice balance of reasoning 
and testing I've written a-couple papers on this on my 
website that spell out some of these things in a bit-more 
detail feel free to check those out thank you guys very 
much-[Applause]
