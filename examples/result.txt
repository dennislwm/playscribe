# SUMMARY
Scott Hansen discusses Terraform integration in GitLab, demonstrating how to use GitLab as a backend for Terraform state files and manage deployments.

# IDEAS:
- GitLab can store Terraform state files, eliminating the need for external storage solutions.
- Terraform commands in GitLab are prefixed with "gitlab-", simplifying usage.
- Using GitLab as a backend allows for better management of state files across branches.
- The project example involves deploying a simple Lambda function that generates random numbers.
- A common S3 bucket is used to maintain resources regardless of the branch.
- Caching mechanisms in GitLab CI/CD pipelines improve efficiency by reusing data across jobs.
- The importance of separating common infrastructure from application-specific resources is highlighted.
- GitLab CI/CD allows for dynamic URLs for review apps based on branch names.
- Manual approval processes can be integrated into deployment pipelines for better control.
- The use of OIDC tokens for authentication between GitLab and AWS enhances security.
- Terraform plans can be reviewed before applying changes, ensuring transparency.
- The ability to automate environment destruction helps manage costs effectively.
- Merge request pipelines can trigger deployments, ensuring only approved changes are applied.
- Resource groups in GitLab prevent concurrent deployments to the same environment.
- The integration of code owners can help manage approvals based on specific resource changes.
- The demo project is designed to showcase best practices in using Terraform with GitLab CI/CD.

# QUOTES:
- "You can essentially use GitLab as a Terraform backend."
- "I don't want to include that in my application Terraform because if I do that then if I tear it down for a feature branch then I tear down the bucket as well."
- "I'm using cache to cache my Terraform directory just so I have that available to all the downstream jobs."
- "This is just a straightforward Lambda function."
- "In real application, I would say your comment would sit inside of its own project."
- "The caching here is going to cache this Terraform directory."
- "This is where the magic happens."
- "You can see here where I have like domain prefix app version S3 bucket."
- "This is just going to run a GitLab Terraform plan."
- "You can have merge request approvals on here."
- "This is just creating that zip file."
- "You could theoretically also package them as artifacts and pass them along."
- "This is going to give you a Terraform report here."
- "You can look at those changes there but that gives you a quick look here."
- "This is showing as there is no stop button here because it's in a stopping state."
- "You can see what it currently looks like and then I can go to feature A."

# FACTS:
- GitLab CI/CD supports caching mechanisms for improved efficiency.
- Terraform state files can be managed directly within GitLab.
- AWS Lambda functions can be deployed using Terraform configurations.
- Dynamic URLs for applications can be generated based on branch names.
- GitLab allows for manual job approvals in CI/CD pipelines.
- The integration of OIDC tokens enhances security between services.
- Resource groups in GitLab prevent concurrent deployments to the same environment.
- The use of S3 buckets is common for storing application artifacts.
- Merge requests in GitLab can trigger automated deployment pipelines.
- The caching mechanism ensures consistent data across jobs in pipelines.

# REFERENCES:
- Terraform documentation and helper tools provided by GitLab.
- Example project demonstrating Lambda function deployment.
- GitLab CI YAML configurations for managing environments and deployments.

# RECOMMENDATIONS:
- Utilize GitLab as a backend for managing Terraform state files to streamline workflows.
- Separate common infrastructure from application-specific resources to avoid accidental deletions.
- Implement caching in CI/CD pipelines to enhance performance and reduce redundant operations.
- Use dynamic URLs for review apps to facilitate easier testing and feedback loops.
- Set up manual approval processes for critical deployments to ensure oversight.
- Leverage OIDC tokens for secure authentication between GitLab and AWS services.
- Regularly review Terraform plans before applying changes to maintain control over infrastructure.
- Automate environment destruction to manage costs effectively and prevent resource sprawl.
- Consider using resource groups in GitLab to manage concurrent deployments efficiently.
- Explore the use of code owners for better management of resource changes and approvals.
